Practical 1
##################################################################################
Set A
(1)
Implement the C Program to create a child process using fork(), 
display parent and child process id. Child process will display the message 
“I am Child Process” and the parent process should display
“I am Parent Process”.

#include <stdio.h>
#include <sys/types.h>
#include <unistd.h>

int main()
{
    // fork() Create a child process

    int pid = fork();
    if (pid > 0) {
        printf("I am Parent process\n");
        printf("ID : %d\n\n", getpid());
    }
    else if (pid == 0) {
        printf("I am Child process\n");
        // getpid() will return process id of child process
        printf("ID: %d\n", getpid());
    
    }
    else {
        printf("Failed to create child process");
    }

    return 0;
}
##################################################################################

##################################################################################
(2) Write a program that demonstrates the use of nice() system call.
 After a child process is started using fork(), assign higher priority 
 to the child using nice() system call.

  #include <stdio.h>
#include <sys/types.h>
#include <unistd.h>
int main()
{
pid_t pid;
pid = fork();
if (pid == 0)
{
printf("\nI am child process, id=%d\n",getpid());
printf("\nPriority :%d,id=%d\n",nice (-7),getpid());
}
else
{
printf("\nI am parent process, id=%d\n",getpid());
nice(1);
printf("\nPriority :%d,id=%d\n",nice (15),getpid());
}
return 0;
}
##################################################################################

##################################################################################
Set B 
(1) Implement the C program to accept n integers to be sorted.
Main function creates child process  using  fork  system  call. 
Parent  process  sorts  the  integers  using  bubble  sort  and waits
for  child  process  using  wait  system  call.  Child  process  sorts 
the  integers  using insertion sort. 

#include<stdio.h>
#include<sys/types.h>
#include<unistd.h>
#include<stdlib.h>
		
void bubblesort(int arr[30],int n)
{
	int i,j,temp;
	for(i=0;i<n;i++)
	{
		for(j=0;j<n-1;j++)
		{
			if(arr[j]>arr[j+1])
			{
				temp=arr[j];
				arr[j]=arr[j+1];
				arr[j+1]=temp;
			}
		}
	}
}

void insertionsort(int arr[30], int n) 
{  
    int i, j, temp;  
    for (i = 1; i < n; i++) {  
        temp = arr[i];  
        j = i - 1;  
  
        while(j>=0 && temp <= arr[j]) 
        {    
            arr[j+1] = arr[j];     
            j = j-1;    
        }    
        arr[j+1] = temp;    
    }  
}  
void fork1()
{
 	int arr[25],arr1[25],n,i,status;
 	printf("\nEnter the no of values in array :");
 	scanf("%d",&n);
 	printf("\nEnter the array elements :");
 	for(i=0;i<n;i++)
    		scanf("%d",&arr[i]);
 	int pid=fork();
  	if(pid==0)
   	{
      		sleep(10);
      		printf("\nchild process\n");
      		printf("child process id=%d\n",getpid());
      		insertionsort(arr,n);
       		printf("\nElements Sorted Using insertionsort:");
     		printf("\n");
       		for(i=0;i<n;i++)
    			printf("%d,",arr[i]);
    		printf("\b");
     		printf("\nparent process id=%d\n",getppid());
     		system("ps -x");
       }    
      else
       {
     		printf("\nparent process\n");
     		printf("\nparent process id=%d\n",getppid());
	 	bubblesort(arr,n);	      
		printf("Elements Sorted Using bubblesort:");
     		printf("\n");
      		for(i=0;i<n;i++)
    			printf("%d,",arr[i]);
    		printf("\n\n\n"); 
      } 
 }     
 int main()
 {
   	fork1();
   	return 0;
 }  
 
##################################################################################
##################################################################################
(2) Write a C program to  illustrate the  concept of  orphan process. 
Parent process  creates a child and terminates before child has finished 
its task. So child process becomes orphan process. 
(Use fork(), sleep(), getpid(), getppid()). 

/*
#include <stdio.h> 
#include <sys/types.h>
#include <unistd.h>
int main()
{ 
 int pid;
 pid=getpid(); 
 printf("Current Process ID is : %d\n",pid); 
 printf("\n[Forking Child Process ... ] \n"); 
 pid=fork(); 
 if(pid < 0) 
 {    
  printf("\nProcess can not be created ");
 } 
 else
 {
         if(pid==0)
  { 
   printf("\nChild Process is Sleeping ..."); 
   sleep(5); 
   printf("\nOrphan Child's Parent ID : %d",getppid()); 
  }
 
  else
  { // Parent Process 
   printf("\nParent Process Completed ..."); 
  } 
 }
 return 0; 
}

*/

#include <stdio.h>
#include <sys/types.h>
#include <unistd.h>

int main()
{
    // fork() Create a child process

    int pid = fork();
    if (pid > 0) {
        //getpid() returns process id
        // while getppid() will return parent process id
        printf("Parent process\n");
        printf("ID : %d\n\n", getpid());
    }
    else if (pid == 0) {
        printf("Child process\n");
        // getpid() will return process id of child process
        printf("ID: %d\n", getpid());
        // getppid() will return parent process id of child process
        printf("Parent -ID: %d\n\n", getppid());

        sleep(10);

        // At this time parent process has finished.
        // So if u will check parent process id
        // it will show different process id
        printf("\nChild process \n");
        printf("ID: %d\n", getpid());
        printf("Parent -ID: %d\n", getppid());
    }
    else {
        printf("Failed to create child process");
    }

    return 0;
}

##################################################################################
##################################################################################
Set C 
(1)implement  the  C  program  that  accepts  an  integer  array.
  Main  function  forks  child process. Parent process sorts an 
  integer array and passes the sorted array to child process through 
   the  command  line  arguments  of  execve()  system  call.
   The  child  process  uses execve() system call to load new program
    that uses this sorted array for performing the binary search to search 
    the particular item in the array

    #include<stdio.h>
#include<stdlib.h>
#include<unistd.h>
#include<sys/types.h>

void main()
{
    int n,i;
    printf("Enter the number of array\n");
    scanf("%d",&n);
    int a[n];
    printf("Enter the array elements:\n");
    for(i=0;i<n;i++)
    {
        scanf("%d",&a[i]);
    }

    void ascending(int *a,int n);
    void descending(int *a,int n);

    pid_t pid;
    pid=fork();

    if(pid<0)
    {
        printf("fork() error\n");
        exit(-1);
    }

    else if(pid==0)
    {
        printf("\n Child Process\n");
        descending(a,n);
        printf("Array elements in descending order\n ");
        for(i=0;i,n;i++)
        {
            printf("%d\n",a[i]);
        }
        printf("\n");
        exit(0);
    }

    else
    {
        int status;
        wait(NULL);
        printf("Parent Process\n");
        if(WIFEXITED(status))
        {
            printf("Child Process Exit ");
        }
        ascending(a,n);
        printf("\n Array Elemets in sort");
        for(i=0;i<n;i++)
        {
            printf("%d\n",a[i]);
        }
        printf("\n");
        exit(0);
    }

    void ascending(int *a,int n)
    {
        int i,j,temp;
        for(i=0;i<n;i++)
        {
            for(j=0;j<n-1;j++)
            {
                if(a[j+1]<a[j])
                {
                    temp=a[j];
                    a[j]=a[j+1];
                    a[j+1]=temp;
                }
            }
        }
    }

    void descending(int *a,int n)
    {
        int i,j,temp;
        for(i=0;i<n;i++)
        {
            for(j=0;j<n-1-i;j++)
            {
                if(a[j+1]>a[j])
                {
                    temp=a[j];
                    a[j]=a[j+1];
                    a[j+1]=temp;
                }
            }
        }
    }
}

##################################################################################
##################################################################################
(2) Implement the C Program to create a child process 
using fork(), Using exec() system call, child process will execute the 
program specified in Set A(1) and parent will continue by printing
 message “I am parent “


#include<stdio.h>
#include<sys/types.h>
#include<unistd.h>

int main()
{
    pid_t pid;
    pid=fork();
    char*args[]={"./=p1",NULL};
    if(pid==0)
     execv(args[0],args);
    else
     printf("I am parent\n");
    
    return 0;
}

##################################################################################
##################################################################################
Practical 2: 
Set A
Write a C program that behaves like a shell which displays the command
prompt ‘myshell$’. It accepts the command,  tokenize the command line 
and execute it  by creating the child process. Also implement the additional
command ‘count’ as 
myshell$ count c  filename: It will display the number of characters in given file 
myshell$ count w filename: It will display the number of words in given file 
myshell$ count l  filename: It will display the number of lines in given file  

#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
void make_toks(char *s, char *tok[])
{
int i=0;
char *p;
p = strtok(s," ");
while(p!=NULL)
{
 tok[i++]=p;
 p=strtok(NULL," ");
}
tok[i]=NULL;
}
void count(char *fn, char op)
{
int fh,cc=0,wc=0,lc=0;
char c;
fh = open(fn,O_RDONLY);
if(fh==-1)
{
 printf("File %s not found.\n",fn);
return;
}
while(read(fh,&c,1)>0)
{
if(c==' ') wc++;
else if(c=='\n')
 {
 wc++;
 lc++;
 }
 cc++;
}
close(fh);
switch(op)
{
case 'c':
 printf("No.of characters:%d\n",cc-1);
break;
case 'w':
 printf("No.of words:%d\n",wc);
break;
case 'l':
 printf("No.of lines:%d\n",lc+1);
break;
}
}
int main()
{
char buff[80],*args[10];
int pid;
while(1)
{
 printf("myshell$ ");
 fflush(stdin);
 fgets(buff,80,stdin);
 buff[strlen(buff)-1]='\0';
 make_toks(buff,args);
if(strcmp(args[0],"count")==0)
 count(args[2],args[1][0]);
else
 {
 pid = fork();
 if(pid>0)
 wait();
 else
 {
 if(execvp(args[0],args)==-1)
 printf("Bad command.\n");
 }
 }
}
return 0;
}

/*output: gcc P2_1.c -o myexe
./ myexe
$myshell: count c Ass2.txt
count w Ass2.txt
count l Ass2.txt*/
##################################################################################
Set B
Write a C program that behaves like a shell which displays the
command prompt ‘myshell$’. It accepts the command, 
tokenize the command line and execute it by creating 
the child process. Also implement the additional command ‘list’ as 
myshell$ list f dirname: It will display filenames in a given directory.
myshell$ list n  dirname: It will count the number of entries in a given directory. 
myshell$ list i dirname: It will display filenames and their 
inode number for the files in a given directory. 

#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <dirent.h>

void make_toks(char *s, char *tok[])
{
 int i=0;
 char *p;

 p = strtok(s," ");
 while(p!=NULL)
 {
  tok[i++]=p;
  p=strtok(NULL," ");
 }

 tok[i]=NULL;
}

void list(char *dn, char op)
{
 DIR *dp;
 struct dirent *entry;
 int dc=0,fc=0;

 dp = opendir(dn);
 if(dp==NULL)
 {
  printf("Dir %s not found.\n",dn);
  return;
 }

 switch(op)
 {
 case 'f':
  while(entry=readdir(dp))
  {
   if(entry->d_type==DT_REG)
    printf("%s\n",entry->d_name);
  }
  break;
 case 'n':
  while(entry=readdir(dp))
  {
   if(entry->d_type==DT_DIR) dc++;
   if(entry->d_type==DT_REG) fc++;
  }
 
  printf("%d Dir(s)\t%d File(s)\n",dc,fc);
  break;
 case 'i':
  while(entry=readdir(dp))
  {
   if(entry->d_type==DT_REG)
    printf("%s\t%d\n",entry->d_name,entry->d_fileno);
  }
 }

 closedir(dp);
}

int main()
{
 char buff[80],*args[10];
 int pid;

 while(1)
 {
  printf("myshell$");
  fflush(stdin);
  fgets(buff,80,stdin);
  buff[strlen(buff)-1]='\0';
  make_toks(buff,args);
  if(strcmp(args[0],"list")==0)
   list(args[2],args[1][0]);
  else
  {
   pid = fork();
   if(pid>0)
    wait();
   else
   {
    if(execvp(args[0],args)==-1)
     printf("Bad command.\n");
   }
  }
 }

 return 0;
}
##################################################################################
##################################################################################
Set C
(1) Write a C program that behaves like a shell which displays the command 
prompt ‘myshell$’. It accepts the command, tokenize the command line and
execute it by creating the child process. Also implement the additional
command ‘typeline’ as 
myshell$ typeline n filename: It will display first n lines of the file. 
myshell$ typeline -n filename: It will display last n lines of the file. 
myshell$ typeline  a filename: It will display all the lines of the file.


#include <sys/types.h>
#include <sys/stat.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <dirent.h>
#include <unistd.h>
int make_toks(char *s, char *tok[]) {
int i = 0;
char *p;
p = strtok(s, " ");
while(p != NULL) {
tok[i++] = p;
p = strtok(NULL, " ");
}
tok[i] = NULL;Set C
(1) Write a C program that behaves like a shell which displays the command 
prompt ‘myshell$’. It accepts the command, tokenize the command line and
execute it by creating the child process. Also implement the additional
command ‘typeline’ as 
myshell$ typeline n filename: It will display first n lines of the file. 
myshell$ typeline -n filename: It will display last n lines of the file. 
myshell$ typeline  a filename: It will display all the lines of the file.

return i;
}
void typeline(char *op, char *fn) {
int fh,
i,
j,
n;
char c;
fh = open(fn, O_RDONLY);
if(fh == -1) {
printf("File %s not found.\n", fn);
return;
}
if(strcmp(op, "a") == 0) {
while(read(fh, &c, 1) > 0)
printf("%c", c);
close(fh);
return;
}
n = atoi(op);
if(n > 0) {
i = 0;
while(read(fh, &c, 1) > 0) {
printf("%c", c);
if(c == '\n') i++;
if(i == n) break;
}
}
if(n < 0) {
i = 0;
while(read(fh, &c, 1) > 0) {
if(c == '\n') i++;
}
lseek(fh, 0, SEEK_SET);
j = 0;
while(read(fh, &c, 1) > 0) {
if(c == '\n') j++;
if(j == i+n+1) break;
}
while(read(fh, &c, 1) > 0) {
printf("%c", c);
}
}
close(fh);
}
int main() {
char buff[80],
*args[10];
while(1) {
printf ("\n");
printf("\nmyshell$ ");
fgets(buff, 80, stdin);
buff[strlen(buff)-1] = '\0';
int n = make_toks(buff, args);
switch (n) {
case 1:
if(strcmp(args[0], "exit") == 0)
exit(1);
if (!fork())
execlp (args [0], args[0], NULL);
break;
case 2:
if (!fork ())
execlp (args [0], args[0], args[1], NULL);
break;
case 3:
if (strcmp(args[0], "typeline") == 0)
typeline (args[1], args[2]);
else {
if (!fork ())
execlp (args [0], args[0], args[1], args[2], NULL);
}
break;
case 4:
if (!fork ())
execlp (args [0], args [0], args [1], args [2], args [3], NULL);
break;
}
}
return 0;
}

/*Output
myshell$ typeline a text.txt
pune
kolkata
doremon
mumbai
vadapav
chandigarh
pune
prisonbreak
pogo
misalpav
gogo
pune
\0
myshell$ typeline 3 text.txt
pune
kolkata
doremon
myshell$ typeline -5 text.txt
pogo
misalpav
gogo
pune
*/
##################################################################################
##################################################################################
(2) Write a C program that behaves like a shell which displays the command prompt
‘myshell$’. It accepts the command, tokenize the command line and execute
it by creating the child process. Also implement the additional command
‘search’ as 
myshell$ search   f  filename pattern : It will search the first occurrence of pattern in the given file
myshell$ search a filename pattern : It will search all the occurrence of pattern in the given file
myshell$  search  c  filename  pattern  :  It  will  count  the  number  of  occurrence  of  pattern  in  the given file

#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

void make_toks(char *s, char *tok[])
{
 int i=0;
 char *p;

 p = strtok(s," ");
 while(p!=NULL)
 {
  tok[i++]=p;
  p=strtok(NULL," ");
 }

 tok[i]=NULL;
}

void search(char *fn, char op, char *pattern)
{
 int fh,count=0,i=0,j=0;
 char buff[255],c,*p;

 fh = open(fn,O_RDONLY);
 if(fh==-1)
 {
  printf("File %s Not Found\n",fn);
  return;
 }

 switch(op)
 {
 case 'f':
  while(read(fh,&c,1))
  {
   buff[j++]=c;
   if(c=='\n')
   {
    buff[j]='\0';
    j=0;
    i++;
    if(strstr(buff,pattern))
    {
     printf("%d: %s",i,buff);
     break;
    }
   }
  }
  break;
 case 'c':
  while(read(fh,&c,1))
  {
   buff[j++]=c;
   if(c=='\n')
   {
    buff[j]='\0';
    j=0;
    p = buff;
    while(p=strstr(p,pattern))
    {
     count++;
     p++;
    }
   }
  }
  printf("Total No.of Occurrences = %d\n",count);
  break;
 case 'a':
  while(read(fh,&c,1))
  {
   buff[j++]=c;
   if(c=='\n')
   {
    buff[j]='\0';
    j = 0;
    i++;
    if(strstr(buff,pattern))
     printf("%d: %s",i,buff);
   }
  }
 }//switch
 close(fh);
}//search

int main()
{
 char buff[80],*args[10];
 int pid;

 while(1)
 {
  printf("myshell$");
  fflush(stdin);
  fgets(buff,80,stdin);
  buff[strlen(buff)-1]='\0';
  make_toks(buff,args);
  if(strcmp(args[0],"search")==0)
   search(args[3],args[1][0],args[2]);
  else
  {
   pid = fork();
   if(pid>0)
    wait();
   else
   {
    if(execvp(args[0],args)==-1)
     printf("Bad command.\n");
   }
  }
 }

 return 0;
}

##################################################################################
##################################################################################
Practical 3

Set A:  
i. Write the  program to  simulate  FCFS CPU-scheduling. 
 The arrival time  and  first CPU- burst for different n number of processes 
 should be input to the algorithm. Assume that the fixed IO waiting time 
 (2 units). The next CPU-burst should be generated randomly.
  The output should give Gantt chart, turnaround time and waiting time
   for each process. Also find the average waiting time and turnaround time.

   // FCFS CPU-scheduling. 
#include<stdio.h>
#include<stdlib.h>
#include<string.h>

typedef struct process_info
{
 char pname[20];
 int at,bt,ct,bt1;
 struct process_info *next;
}NODE;

int n;
NODE *first,*last;

void accept_info()
{
 NODE *p;
 int i;

 printf("Enter no.of process:");
 scanf("%d",&n);

 for(i=0;i<n;i++)
 {
  p = (NODE*)malloc(sizeof(NODE));

  printf("Enter process name:");
  scanf("%s",p->pname);

  printf("Enter arrival time:");
  scanf("%d",&p->at);

  printf("Enter first CPU burst time:");
  scanf("%d",&p->bt);

  p->bt1 = p->bt;
  
  p->next = NULL;

  if(first==NULL)
   first=p;
  else
   last->next=p;

  last = p;
 }
}

void print_output()
{
 NODE *p;
 float avg_tat=0,avg_wt=0;

 printf("pname\tat\tbt\tct\ttat\twt\n");

 p = first;
 while(p!=NULL)
 {
  int tat = p->ct-p->at;
  int wt = tat-p->bt;
  
  avg_tat+=tat;
  avg_wt+=wt;

  printf("%s\t%d\t%d\t%d\t%d\t%d\n",
   p->pname,p->at,p->bt,p->ct,tat,wt);
  
  p=p->next;
 }

 printf("Avg TAT=%f\tAvg WT=%f\n",
   avg_tat/n,avg_wt/n);
}

void print_input()
{
 NODE *p;

 p = first;
 
 printf("pname\tat\tbt\n");
 while(p!=NULL)
 {
  printf("%s\t%d\t%d\n",
   p->pname,p->at,p->bt1);
  p = p->next;
 }
}

void sort()
{
 NODE *p,*q;
 int t;
 char name[20];

 p = first;
 while(p->next!=NULL)
 {
  q=p->next;
  while(q!=NULL)
  {
   if(p->at > q->at)
   {
    strcpy(name,p->pname);
    strcpy(p->pname,q->pname);
    strcpy(q->pname,name);

    t = p->at;
    p->at = q->at;
    q->at = t;
    
    t = p->bt;
    p->bt = q->bt;
    q->bt = t;

    t = p->ct;
    p->ct = q->ct;
    q->ct = t;

    t = p->bt1;
    p->bt1 = q->bt1;
    q->bt1 = t;
   }

   q=q->next;
  }
 
  p=p->next;
 }
}

int time;

NODE * get_fcfs()
{
 NODE *p;

 p = first;
 while(p!=NULL)
 {
  if(p->at<=time && p->bt1!=0)
   return p;

  p=p->next;
 }

 return NULL;
}

struct gantt_chart
{
 int start;
 char pname[30];
 int end;
}s[100],s1[100];

int k;

void fcfs()
{
 int prev=0,n1=0;
 NODE *p;

 while(n1!=n)
 {
  p = get_fcfs();

  if(p==NULL)
  {
   time++;
   s[k].start = prev;
   strcpy(s[k].pname,"*");
   s[k].end = time;

   prev = time;
   k++;
  }
  else
  {
   time+=p->bt1;
   s[k].start = prev;
   strcpy(s[k].pname, p->pname);
   s[k].end = time;

   prev = time;
   k++;

   p->ct = time;
   p->bt1 = 0;

   n1++;
  }

  print_input(); 
  sort();
 }
}

void print_gantt_chart()
{
 int i,j,m;

 s1[0] = s[0];
 
 for(i=1,j=0;i<k;i++)
 {
  if(strcmp(s[i].pname,s1[j].pname)==0)
   s1[j].end = s[i].end;
  else
   s1[++j] = s[i];
 }

 printf("%d",s1[0].start);
 for(i=0;i<=j;i++)
 {
  m = (s1[i].end - s1[i].start);

  for(k=0;k<m/2;k++)
   printf("-");

  printf("%s",s1[i].pname);

  for(k=0;k<(m+1)/2;k++)
   printf("-");

  printf("%d",s1[i].end);
 }
}

int main()
{
 accept_info();
 sort();
 fcfs();
 print_output();
 print_gantt_chart();

 return 0;
}

/*
Output:


Enter no.of process:5
Enter process name:p1
Enter arrival time:3
Enter first CPU burst time:4
Enter process name:p2
Enter arrival time:5
Enter first CPU burst time:3
Enter process name:p3
Enter arrival time:0
Enter first CPU burst time:2
Enter process name:p4
Enter arrival time:5
Enter first CPU burst time:1
Enter process name:p5
Enter arrival time:4
Enter first CPU burst time:3

pname	at	bt	ct	tat	wt
p3	0	2	2	2	0
p1	3	4	7	4	0
p5	4	3	10	6	3
p4	5	1	11	6	5
p2	5	3	14	9	6

Avg TAT=5.400000	Avg WT=2.800000

0-p3-2*-3--p1--7-p5--10p4-11-p2--14
*/  
##################################################################################
##################################################################################
ii. Write the program to simulate Non-preemptive Shortest Job First (SJF) -scheduling.
The arrival time and first CPU-burst for different n number of processes
should be input to the algorithm.  Assume  the  fixed  IO  waiting time
(2  units).  The  next  CPU-burst  should  be generated  randomly. 
The  output  should  give  Gantt  chart,  turnaround  time  and  
waiting time for each process. Also find the average waiting time 
and turnaround time.   

//Non-preemptive Shortest Job First (SJF) -scheduling
#include<stdio.h>
#include<stdlib.h>
#include<string.h>

typedef struct process_info
{
 char pname[20];
 int at,bt,ct,bt1;
 struct process_info *next;
}NODE;

int n;
NODE *first,*last;

void accept_info()
{
 NODE *p;
 int i;

 printf("Enter no.of process:");
 scanf("%d",&n);

 for(i=0;i<n;i++)
 {
  p = (NODE*)malloc(sizeof(NODE));

  printf("Enter process name:");
  scanf("%s",p->pname);

  printf("Enter arrival time:");
  scanf("%d",&p->at);

  printf("Enter first CPU burst time:");
  scanf("%d",&p->bt);

  
  p->bt1 = p->bt;
  p->next = NULL;

  if(first==NULL)
   first=p;
  else
   last->next=p;

  last = p;
 }
}

void print_output()
{
 NODE *p;
 float avg_tat=0,avg_wt=0;

 printf("pname\tat\tbt\tct\ttat\twt\n");

 p = first;
 while(p!=NULL)
 {
  int tat = p->ct-p->at;
  int wt = tat-p->bt;
  
  avg_tat+=tat;
  avg_wt+=wt;

  printf("%s\t%d\t%d\t%d\t%d\t%d\n",
   p->pname,p->at,p->bt,p->ct,tat,wt);
  
  p=p->next;
 }

 printf("Avg TAT=%f\tAvg WT=%f\n",
   avg_tat/n,avg_wt/n);
}

void print_input()
{
 NODE *p;

 p = first;
 
 printf("pname\tat\tbt\n");
 while(p!=NULL)
 {
  printf("%s\t%d\t%d\n",
   p->pname,p->at,p->bt1);
  p = p->next;
 }
}

void sort()
{
 NODE *p,*q;
 int t;
 char name[20];

 p = first;
 while(p->next!=NULL)
 {
  q=p->next;
  while(q!=NULL)
  {
   if(p->at > q->at)
   {
    strcpy(name,p->pname);
    strcpy(p->pname,q->pname);
    strcpy(q->pname,name);

    t = p->at;
    p->at = q->at;
    q->at = t;
    
    t = p->bt;
    p->bt = q->bt;
    q->bt = t;

    t = p->ct;
    p->ct = q->ct;
    q->ct = t;

    t = p->bt1;
    p->bt1 = q->bt1;
    q->bt1 = t;
   
   }

   q=q->next;
  }
 
  p=p->next;
 }
}

int time;

NODE * get_sjf()
{
 NODE *p,*min_p=NULL;
 int min=9999;

 p = first;
 while(p!=NULL)
 {
  if(p->at<=time && p->bt1!=0 &&
   p->bt1<min)
  {
   min = p->bt1;
   min_p = p;
  }
  p=p->next;
 }

 return min_p;
}

struct gantt_chart
{
 int start;
 char pname[30];
 int end;
}s[100],s1[100];

int k;

void sjfnp()
{
 int prev=0,n1=0;
 NODE *p;

 while(n1!=n)
 {
  p = get_sjf();

  if(p==NULL)
  {
   time++;
   s[k].start = prev;
   strcpy(s[k].pname,"*");
   s[k].end = time;

   prev = time;
   k++;
  }
  else
  {
   time+=p->bt1;
   s[k].start = prev;
   strcpy(s[k].pname, p->pname);
   s[k].end = time;

   prev = time;
   k++;

   p->ct = time;
   p->bt1 = 0;

   n1++;
  }

  print_input(); 
  sort();
 }
}

void print_gantt_chart()
{
 int i,j,m;

 s1[0] = s[0];
 
 for(i=1,j=0;i<k;i++)
 {
  if(strcmp(s[i].pname,s1[j].pname)==0)
   s1[j].end = s[i].end;
  else
   s1[++j] = s[i];
 }

 printf("%d",s1[0].start);
 for(i=0;i<=j;i++)
 {
  m = (s1[i].end - s1[i].start);

  for(k=0;k<m/2;k++)
   printf("-");

  printf("%s",s1[i].pname);

  for(k=0;k<(m+1)/2;k++)
   printf("-");

  printf("%d",s1[i].end);
 }
}

int main()
{
 accept_info();
 sort();
 sjfnp();
 print_output();
 print_gantt_chart();

 return 0;
}


/*
Output:


Enter no.of process:4
Enter process name:p1
Enter arrival time:1
Enter first CPU burst time:5
Enter process name:p2
Enter arrival time:0
Enter first CPU burst time:7
Enter process name:p3
Enter arrival time:3
Enter first CPU burst time:3
Enter process name:p4
Enter arrival time:2
Enter first CPU burst time:10

pname	at	bt	ct	tat	wt
p2	0	7	7	7	0
p1	1	5	15	14	9
p4	2	10	25	23	13
p3	3	3	10	7	4

Avg TAT=12.750000	Avg WT=6.500000

0---p2----7-p3--10--p1---15-----p4-----25

*/

##################################################################################
##################################################################################
Set B:  
i.
Write  the  program  to  simulate  Preemptive  Shortest  Job  First  (SJF)  -scheduling.
  The arrival time and first CPU-burst for different n number of processes 
  should be input to the algorithm.  Assume  the  fixed  IO  waiting time 
   (2  units).  The  next  CPU-burst  should  be generated  randomly. 
    The  output  should  give  Gantt  chart,  turnaround  time  and  
    waiting time for each process. Also find the average waiting time 
    and turnaround time.

// Preemptive Shortest Job First (SJF) -scheduling
#include<stdio.h>
#include<stdlib.h>
#include<string.h>

typedef struct process_info
{
 char pname[20];
 int at,bt,ct,bt1;
 struct process_info *next;
}NODE;

int n;
NODE *first,*last;

void accept_info()
{
 NODE *p;
 int i;

 printf("Enter no.of process:");
 scanf("%d",&n);

 for(i=0;i<n;i++)
 {
  p = (NODE*)malloc(sizeof(NODE));

  printf("Enter process name:");
  scanf("%s",p->pname);

  printf("Enter arrival time:");
  scanf("%d",&p->at);

  printf("Enter first CPU burst time:");
  scanf("%d",&p->bt);

  p->bt1 = p->bt;
  
  p->next = NULL;

  if(first==NULL)
   first=p;
  else
   last->next=p;

  last = p;
 }
}

void print_output()
{
 NODE *p;
 float avg_tat=0,avg_wt=0;

 printf("pname\tat\tbt\tct\ttat\twt\n");

 p = first;
 while(p!=NULL)
 {
  int tat = p->ct-p->at;
  int wt = tat-p->bt;
  
  avg_tat+=tat;
  avg_wt+=wt;

  printf("%s\t%d\t%d\t%d\t%d\t%d\n",
   p->pname,p->at,p->bt,p->ct,tat,wt);
  
  p=p->next;
 }

 printf("Avg TAT=%f\tAvg WT=%f\n",
   avg_tat/n,avg_wt/n);
}

void print_input()
{
 NODE *p;

 p = first;
 
 printf("pname\tat\tbt\n");
 while(p!=NULL)
 {
  printf("%s\t%d\t%d\n",
   p->pname,p->at,p->bt1);
  p = p->next;
 }
}

void sort()
{
 NODE *p,*q;
 int t;
 char name[20];

 p = first;
 while(p->next!=NULL)
 {
  q=p->next;
  while(q!=NULL)
  {
   if(p->at > q->at)
   {
    strcpy(name,p->pname);
    strcpy(p->pname,q->pname);
    strcpy(q->pname,name);

    t = p->at;
    p->at = q->at;
    q->at = t;
    
    t = p->bt;
    p->bt = q->bt;
    q->bt = t;

    t = p->ct;
    p->ct = q->ct;
    q->ct = t;

    t = p->bt1;
    p->bt1 = q->bt1;
    q->bt1 = t;
   }

   q=q->next;
  }
 
  p=p->next;
 }
}

int time;

NODE * get_sjf()
{
 NODE *p,*min_p=NULL;
 int min=9999;

 p = first;
 while(p!=NULL)
 {
  if(p->at<=time && p->bt1!=0 &&
   p->bt1<min)
  {
   min = p->bt1;
   min_p = p;
  }
  p=p->next;
 }

 return min_p;
}

struct gantt_chart
{
 int start;
 char pname[30];
 int end;
}s[100],s1[100];

int k;

void sjfp()
{
 int prev=0,n1=0;
 NODE *p;

 while(n1!=n)
 {
  p = get_sjf();

  if(p==NULL)
  {
   time++;
   s[k].start = prev;
   strcpy(s[k].pname,"*");
   s[k].end = time;

   prev = time;
   k++;
  }
  else
  {
   time++;
   s[k].start = prev;
   strcpy(s[k].pname, p->pname);
   s[k].end = time;

   prev = time;
   k++;

   p->ct = time;
   p->bt1--;

   if(p->bt1==0)
    n1++;
  }

  print_input(); 
  sort();
 }
}

void print_gantt_chart()
{
 int i,j,m;

 s1[0] = s[0];
 
 for(i=1,j=0;i<k;i++)
 {
  if(strcmp(s[i].pname,s1[j].pname)==0)
   s1[j].end = s[i].end;
  else
   s1[++j] = s[i];
 }

 printf("%d",s1[0].start);
 for(i=0;i<=j;i++)
 {
  m = (s1[i].end - s1[i].start);

  for(k=0;k<m/2;k++)
   printf("-");

  printf("%s",s1[i].pname);

  for(k=0;k<(m+1)/2;k++)
   printf("-");

  printf("%d",s1[i].end);
 }
}

int main()
{
 accept_info();
 sort();
 sjfp();
 print_output();
 print_gantt_chart();

 return 0;
}

/*
Output:
Enter no.of process:4
Enter process name:p1
Enter arrival time:1
Enter first CPU burst time:5
Enter process name:p2
Enter arrival time:0
Enter first CPU burst time:7
Enter process name:p3
Enter arrival time:3
Enter first CPU burst time:3
Enter process name:p3
Enter arrival time:2
Enter first CPU burst time:10

pname	at	bt	ct	tat	wt
p2	0	7	15	15	8
p1	1	5	6	5	0
p3	2	10	25	23	13
p3	3	3	9	6	3
Avg TAT=12.250000	Avg WT=6.000000
0p2-1--p1---6-p3--9---p2---15-----p3-----25
*/   
##################################################################################
##################################################################################
ii.
Write the program to simulate Non-preemptive Priority scheduling. 
The arrival time and first CPU-burst and  priority for  different n  
number of  processes should be  input  to the algorithm. 
 Assume  the  fixed  IO  waiting time  (2  units).  
 The  next  CPU-burst  should  be generated  randomly. 
  The  output  should  give  Gantt  chart,  turnaround  time  and 
   waiting time for each process. Also find the average waiting time 
   and turnaround time.

   //Priority Scheduling
#include<stdio.h>
#include<stdlib.h>
#include<string.h>

typedef struct process_info
{
 char pname[20];
 int at,bt,ct,bt1,p;
 struct process_info *next;
}NODE;

int n;
NODE *first,*last;

void accept_info()
{
 NODE *p;
 int i;

 printf("Enter no.of process:");
 scanf("%d",&n);

 for(i=0;i<n;i++)
 {
  p = (NODE*)malloc(sizeof(NODE));

  printf("Enter process name:");
  scanf("%s",p->pname);

  printf("Enter arrival time:");
  scanf("%d",&p->at);

  printf("Enter first CPU burst time:");
  scanf("%d",&p->bt);

  printf("Enter priority:");
  scanf("%d",&p->p);

  p->bt1 = p->bt;
  
  p->next = NULL;

  if(first==NULL)
   first=p;
  else
   last->next=p;

  last = p;
 }
}

void print_output()
{
 NODE *p;
 float avg_tat=0,avg_wt=0;

 printf("pname\tat\tbt\tp\ttct\ttat\twt\n");

 p = first;
 while(p!=NULL)
 {
  int tat = p->ct-p->at;
  int wt = tat-p->bt;
  
  avg_tat+=tat;
  avg_wt+=wt;

  printf("%s\t%d\t%d\t%d\t%d\t%d\t%d\n",
   p->pname,p->at,p->bt,p->p,p->ct,tat,wt);
  
  p=p->next;
 }

 printf("Avg TAT=%f\tAvg WT=%f\n",
   avg_tat/n,avg_wt/n);
}

void print_input()
{
 NODE *p;

 p = first;
 
 printf("pname\tat\tbt\tp\n");
 while(p!=NULL)
 {
  printf("%s\t%d\t%d\t%d\n",
   p->pname,p->at,p->bt1,p->p);
  p = p->next;
 }
}

void sort()
{
 NODE *p,*q;
 int t;
 char name[20];

 p = first;
 while(p->next!=NULL)
 {
  q=p->next;
  while(q!=NULL)
  {
   if(p->at > q->at)
   {
    strcpy(name,p->pname);
    strcpy(p->pname,q->pname);
    strcpy(q->pname,name);

    t = p->at;
    p->at = q->at;
    q->at = t;
    
    t = p->bt;
    p->bt = q->bt;
    q->bt = t;

    t = p->ct;
    p->ct = q->ct;
    q->ct = t;

    t = p->bt1;
    p->bt1 = q->bt1;
    q->bt1 = t;
   
    t = p->p;
    p->p = q->p;
    q->p = t;
   }

   q=q->next;
  }
 
  p=p->next;
 }
}

int time;

NODE * get_p()
{
 NODE *p,*min_p=NULL;
 int min=9999;

 p = first;
 while(p!=NULL)
 {
  if(p->at<=time && p->bt1!=0 &&
   p->p<min)
  {
   min = p->p;
   min_p = p;
  }
  p=p->next;
 }

 return min_p;
}

struct gantt_chart
{
 int start;
 char pname[30];
 int end;
}s[100],s1[100];

int k;

void pnp()
{
 int prev=0,n1=0;
 NODE *p;

 while(n1!=n)
 {
  p = get_p();

  if(p==NULL)
  {
   time++;
   s[k].start = prev;
   strcpy(s[k].pname,"*");
   s[k].end = time;

   prev = time;
   k++;
  }
  else
  {
   time+=p->bt1;
   s[k].start = prev;
   strcpy(s[k].pname, p->pname);
   s[k].end = time;

   prev = time;
   k++;

   p->ct = time;
   p->bt1 = 0;

   n1++;
  }

  print_input(); 
  sort();
 }
}

void print_gantt_chart()
{
 int i,j,m;

 s1[0] = s[0];
 
 for(i=1,j=0;i<k;i++)
 {
  if(strcmp(s[i].pname,s1[j].pname)==0)
   s1[j].end = s[i].end;
  else
   s1[++j] = s[i];
 }

 printf("%d",s1[0].start);
 for(i=0;i<=j;i++)
 {
  m = (s1[i].end - s1[i].start);

  for(k=0;k<m/2;k++)
   printf("-");

  printf("%s",s1[i].pname);

  for(k=0;k<(m+1)/2;k++)
   printf("-");

  printf("%d",s1[i].end);
 }
}

int main()
{
 accept_info();
 sort();
 pnp();
 print_output();
 print_gantt_chart();

 return 0;
}
/*
Output :

Enter no.of process:4
Enter process name:p1
Enter arrival time:0
Enter first CPU burst time:8
Enter priority:4
Enter process name:p2
Enter arrival time:1
Enter first CPU burst time:6
Enter priority:6
Enter process name:p3
Enter arrival time:3
Enter first CPU burst time:7
Enter priority:3
Enter process name:p4
Enter arrival time:3
Enter first CPU burst time:9
Enter priority:1
*/
##################################################################################
##################################################################################
Set C: 
i. 
Write the program to simulate Preemptive Priority scheduling. 
The arrival time and first CPU-burst  and  priority  for  different 
 n  number  of  processes  should  be  input  to  the algorithm.
   Assume  the  fixed  IO  waiting time  (2  units).  The  next 
    CPU-burst  should  be generated  randomly.  The  output  should  
    give  Gantt  chart,  turnaround  time  and  waiting time for each 
    process. Also find the average waiting time and turnaround time.  

    //Priority Scheduling
#include<stdio.h>
#include<stdlib.h>
#include<string.h>

typedef struct process_info
{
 char pname[20];
 int at,bt,ct,bt1,p;
 struct process_info *next;
}NODE;

int n;
NODE *first,*last;

void accept_info()
{
 NODE *p;
 int i;

 printf("Enter no.of process:");
 scanf("%d",&n);

 for(i=0;i<n;i++)
 {
  p = (NODE*)malloc(sizeof(NODE));

  printf("Enter process name:");
  scanf("%s",p->pname);

  printf("Enter arrival time:");
  scanf("%d",&p->at);

  printf("Enter first CPU burst time:");
  scanf("%d",&p->bt);

  printf("Enter priority:");
  scanf("%d",&p->p);

  p->bt1 = p->bt;
  
  p->next = NULL;

  if(first==NULL)
   first=p;
  else
   last->next=p;

  last = p;
 }
}

void print_output()
{
 NODE *p;
 float avg_tat=0,avg_wt=0;

 printf("pname\tat\tbt\tp\ttct\ttat\twt\n");

 p = first;
 while(p!=NULL)
 {
  int tat = p->ct-p->at;
  int wt = tat-p->bt;
  
  avg_tat+=tat;
  avg_wt+=wt;

  printf("%s\t%d\t%d\t%d\t%d\t%d\t%d\n",
   p->pname,p->at,p->bt,p->p,p->ct,tat,wt);
  
  p=p->next;
 }

 printf("Avg TAT=%f\tAvg WT=%f\n",
   avg_tat/n,avg_wt/n);
}

void print_input()
{
 NODE *p;

 p = first;
 
 printf("pname\tat\tbt\tp\n");
 while(p!=NULL)
 {
  printf("%s\t%d\t%d\t%d\n",
   p->pname,p->at,p->bt1,p->p);
  p = p->next;
 }
}

void sort()
{
 NODE *p,*q;
 int t;
 char name[20];

 p = first;
 while(p->next!=NULL)
 {
  q=p->next;
  while(q!=NULL)
  {
   if(p->at > q->at)
   {
    strcpy(name,p->pname);
    strcpy(p->pname,q->pname);
    strcpy(q->pname,name);

    t = p->at;
    p->at = q->at;
    q->at = t;
    
    t = p->bt;
    p->bt = q->bt;
    q->bt = t;

    t = p->ct;
    p->ct = q->ct;
    q->ct = t;

    t = p->bt1;
    p->bt1 = q->bt1;
    q->bt1 = t;
   
    t = p->p;
    p->p = q->p;
    q->p = t;
   }

   q=q->next;
  }
 
  p=p->next;
 }
}

int time;

NODE * get_p()
{
 NODE *p,*min_p=NULL;
 int min=9999;

 p = first;
 while(p!=NULL)
 {
  if(p->at<=time && p->bt1!=0 &&
   p->p<min)
  {
   min = p->p;
   min_p = p;
  }
  p=p->next;
 }

 return min_p;
}

struct gantt_chart
{
 int start;
 char pname[30];
 int end;
}s[100],s1[100];

int k;

void pnp()
{
 int prev=0,n1=0;
 NODE *p;

 while(n1!=n)
 {
  p = get_p();

  if(p==NULL)
  {
   time++;
   s[k].start = prev;
   strcpy(s[k].pname,"*");
   s[k].end = time;

   prev = time;
   k++;
  }
  else
  {
   time+=p->bt1;
   s[k].start = prev;
   strcpy(s[k].pname, p->pname);
   s[k].end = time;

   prev = time;
   k++;

   p->ct = time;
   p->bt1 = 0;

   n1++;
  }

  print_input(); 
  sort();
 }
}

void print_gantt_chart()
{
 int i,j,m;

 s1[0] = s[0];
 
 for(i=1,j=0;i<k;i++)
 {
  if(strcmp(s[i].pname,s1[j].pname)==0)
   s1[j].end = s[i].end;
  else
   s1[++j] = s[i];
 }

 printf("%d",s1[0].start);
 for(i=0;i<=j;i++)
 {
  m = (s1[i].end - s1[i].start);

  for(k=0;k<m/2;k++)
   printf("-");

  printf("%s",s1[i].pname);

  for(k=0;k<(m+1)/2;k++)
   printf("-");

  printf("%d",s1[i].end);
 }
}

int main()
{
 accept_info();
 sort();
 pnp();
 print_output();
 print_gantt_chart();

 return 0;
}
/*
Output :

Enter no.of process:4
Enter process name:p1
Enter arrival time:0
Enter first CPU burst time:8
Enter priority:4
Enter process name:p2
Enter arrival time:1
Enter first CPU burst time:6
Enter priority:6
Enter process name:p3
Enter arrival time:3
Enter first CPU burst time:7
Enter priority:3
Enter process name:p4
Enter arrival time:3
Enter first CPU burst time:9
Enter priority:1
*/
##################################################################################
##################################################################################
ii.
Write the program to simulate Round Robin (RR) scheduling.
The arrival time and first CPU-burst  for  different  n  number  
of processes should  be  input  to  the  algorithm.  Also give  the
time quantum  as  input.  Assume  the  fixed  IO  waiting  time  
(2 units).  The next CPU-burst should be generated randomly.
The output should give Gantt chart, turnaround time  and  waiting
time  for  each  process.  Also  find  the  average  waiting  time
and turnaround time.   

//Round Robin Scheduling (RR)

#include<stdio.h>  

void main()  
{  
    // initlialize the variable name  
    int i, NOP, sum=0,count=0, y, quant, wt=0, tat=0, at[10], bt[10], temp[10];  
    float avg_wt, avg_tat;  
    printf(" Total number of process in the system: ");  
    scanf("%d", &NOP);  
    y = NOP; // Assign the number of process to variable y  
  
// Use for loop to enter the details of the process like Arrival time and the Burst Time  
for(i=0; i<NOP; i++)  
{  
printf("\n Enter the Arrival and Burst time of the Process[%d]\n", i+1);  
printf(" Arrival time is: \t");  // Accept arrival time  
scanf("%d", &at[i]);  
printf(" \nBurst time is: \t"); // Accept the Burst time  
scanf("%d", &bt[i]);  
temp[i] = bt[i]; // store the burst time in temp array  
}  
// Accept the Time qunat  
printf("Enter the Time Quantum for the process: \t");  
scanf("%d", &quant);  
// Display the process No, burst time, Turn Around Time and the waiting time  
printf("\n Process No \t\t Burst Time \t\t TAT \t\t Waiting Time ");  
for(sum=0, i = 0; y!=0; )  
{  
if(temp[i] <= quant && temp[i] > 0) // define the conditions   
{  
    sum = sum + temp[i];  
    temp[i] = 0;  
    count=1;  
    }     
    else if(temp[i] > 0)  
    {  
        temp[i] = temp[i] - quant;  
        sum = sum + quant;    
    }  
    if(temp[i]==0 && count==1)  
    {  
        y--; //decrement the process no.  
        printf("\nProcess No[%d] \t\t %d\t\t\t\t %d\t\t\t %d", i+1, bt[i], sum-at[i], sum-at[i]-bt[i]);  
        wt = wt+sum-at[i]-bt[i];  
        tat = tat+sum-at[i];  
        count =0;     
    }  
    if(i==NOP-1)  
    {  
        i=0;  
    }  
    else if(at[i+1]<=sum)  
    {  
        i++;  
    }  
    else  
    {  
        i=0;  
    }  
}  
// represents the average waiting time and Turn Around time  
avg_wt = wt * 1.0/NOP;  
avg_tat = tat * 1.0/NOP;  
printf("\n Average Turn Around Time: \t%f", avg_wt);  
printf("\n Average Waiting Time: \t%f", avg_tat);  


}  

/*

 Total number of process in the system: 4

 Enter the Arrival and Burst time of the Process[1]
 Arrival time is: 	0
 
Burst time is: 	8

 Enter the Arrival and Burst time of the Process[2]
 Arrival time is: 	1
 
Burst time is: 	5

 Enter the Arrival and Burst time of the Process[3]
 Arrival time is: 	2
 
Burst time is: 	10

 Enter the Arrival and Burst time of the Process[4]
 Arrival time is: 	3
 
Burst time is: 	11
Enter the Time Quantum for the process: 	6

 Process No 		 Burst Time 		 TAT 		 Waiting Time 
Process No[2] 		 5				 10			 5
Process No[1] 		 8				 25			 17
Process No[3] 		 10				 27			 17
Process No[4] 		 11				 31			 20
 Average Turn Around Time: 	14.750000
 Average Waiting Time: 	23.250000
*/
##################################################################################
##################################################################################
Practical 4
Set A 
i.
Write  the  simulation  program  to  implement  demand  paging  and 
show  the  page scheduling and total number of page faults for the
following given page reference string. Give input n as the number of
memory frames. 
    Reference String : 12,15,12,18,6,8,11,12,19,12,6,8,12,15,19,8 
1) Implement FIFO 2) Implement LRU

//FIFO 

#include<stdio.h>
#define MAX 20
int frames[MAX],ref[MAX],mem[MAX][MAX],faults,sp,m,n;
void accept()
{
int i;
printf("Enter no.of frames:");
scanf("%d", &n);
printf("Enter no.of references:");
scanf("%d", &m);
printf("Enter reference string:\n");
for(i=0;i<m;i++)
{
printf("[%d]=",i);
scanf("%d",&ref[i]);
}
}
void disp()
{
int i,j;
for(i=0;i<m;i++)
printf("%3d",ref[i]);
printf("\n\n");
for(i=0;i<n;i++)
{
for(j=0;j<m;j++)
{
if(mem[i][j])
printf("%3d",mem[i][j]);
else
printf(" ");

}
printf("\n");
}
printf("Total Page Faults: %d\n",faults);
}
int search(int pno)
{
int i;
for(i=0;i<n;i++)
{
if(frames[i]==pno)
return i;
}
return -1;
}
void fifo()
{
int i,j;
for(i=0;i<m;i++)
{
if(search(ref[i])==-1)
{
frames[sp] = ref[i];
sp = (sp+1)%n;
faults++;
for(j=0;j<n;j++)
mem[j][i] = frames[j];
}
}
}
int main()
{
accept();
fifo();
disp();
return 0;
}

/*
Output:
Enter no.of frames:4
Enter no.of references:12 15 12 18 6 8 11 12 19 12 6 8 12 15 19 8
Enter reference string:
[0]=[1]=[2]=[3]=[4]=[5]=[6]=[7]=[8]=[9]=[10]=[11]= 15 12 18  6  8 11 12 19 12  6  8 12

 15 15 15 15  8  8  8  8   6  6 
  12 12 12 12 11 11 11  11  8 
   18 18 18 18 12 12  12 12 
     6  6  6  6 19  19 19 
Total Page Faults: 10

*/

//Program (LRU):


#include<stdio.h>
#define MAX 20

int frames[MAX],ref[MAX],mem[MAX][MAX],faults,
sp,m,n,time[MAX];
void accept()
{
int i;
printf("Enter no.of frames:");
scanf("%d", &n);
printf("Enter no.of references:");
scanf("%d", &m);
printf("Enter reference string:\n");
for(i=0;i<m;i++)
{
printf("[%d]=",i);
scanf("%d",&ref[i]);
}
}
void disp()
{
int i,j;
for(i=0;i<m;i++)
printf("%3d",ref[i]);
printf("\n\n");
for(i=0;i<n;i++)
{
for(j=0;j<m;j++)
{
if(mem[i][j])
printf("%3d",mem[i][j]);
else
printf(" ");
}
printf("\n");
}
printf("Total Page Faults: %d\n",faults);
}
int search(int pno)
{
int i;
for(i=0;i<n;i++)
{

if(frames[i]==pno)
return i;
}
return -1;
}
int get_lru()
{
int i,min_i,min=9999;
for(i=0;i<n;i++)
{
if(time[i]<min)
{
min = time[i];
min_i = i;
}
}
return min_i;
}

void lru()
{
int i,j,k;
for(i=0;i<m && sp<n;i++)
{
k=search(ref[i]);
if(k==-1)
{
frames[sp]=ref[i];
time[sp]=i;
faults++;
sp++;
for(j=0;j<n;j++)
mem[j][i]=frames[j];
}
else
time[k]=i;
}
for(;i<m;i++)
{
k = search(ref[i]);
if(k==-1)
{
sp = get_lru();

frames[sp] = ref[i];
time[sp] = i;
faults++;
for(j=0;j<n;j++)
mem[j][i] = frames[j];
}
else
time[k]=i;
}
}

int main()
{
accept();
lru();
disp();
return 0;
}

/*
Output:
Enter no.of frames:4
Enter no.of references:12 15 12 18 6 8 11 12 19 12 6 8 12 15 19 8
Enter reference string:
[0]=[1]=[2]=[3]=[4]=[5]=[6]=[7]=[8]=[9]=[10]=[11]= 15 12 18  6  8 11 12 19 12  6  8 12

 15 15 15 15  8  8  8  8     6  6   
    12 12 12 12 11 11 11    11  8   
       18 18 18 18 12 12    12 12   
           6  6  6  6 19    19 19   
Total Page Faults: 10
*/

##################################################################################
##################################################################################
Set B: 
I.
Write  the  simulation  program  to  implement  demand  paging  
and  show  the  page scheduling and total number of page faults 
for the following given page reference string. Give input n as the 
number of memory frames. 
    Reference String : 12,15,12,18,6,8,11,12,19,12,6,8,12,15,19,8
1) Implement OPT 2) Implement MFU

//Program OPT :

#include<stdio.h>
int main()
{
    int no_of_frames, no_of_pages, frames[10], pages[30], temp[10], flag1, flag2, flag3, i, j, k, pos, max, faults = 0;
    printf("Enter number of frames: ");
    scanf("%d", &no_of_frames);
    
    printf("Enter number of pages: ");
    scanf("%d", &no_of_pages);
    
    printf("Enter page reference string: ");
    
    for(i = 0; i < no_of_pages; ++i){
        scanf("%d", &pages[i]);
    }
    
    for(i = 0; i < no_of_frames; ++i){
        frames[i] = -1;
    }
    
    for(i = 0; i < no_of_pages; ++i){
        flag1 = flag2 = 0;
        
        for(j = 0; j < no_of_frames; ++j){
            if(frames[j] == pages[i]){
                   flag1 = flag2 = 1;
                   break;
               }
        }
        
        if(flag1 == 0){
            for(j = 0; j < no_of_frames; ++j){
                if(frames[j] == -1){
                    faults++;
                    frames[j] = pages[i];
                    flag2 = 1;
                    break;
                }
            }    
        }
        
        if(flag2 == 0){
         flag3 =0;
        
            for(j = 0; j < no_of_frames; ++j){
             temp[j] = -1;
            
             for(k = i + 1; k < no_of_pages; ++k){
             if(frames[j] == pages[k]){
             temp[j] = k;
             break;
             }
             }
            }
            
            for(j = 0; j < no_of_frames; ++j){
             if(temp[j] == -1){
             pos = j;
             flag3 = 1;
             break;
             }
            }
            
            if(flag3 ==0){
             max = temp[0];
             pos = 0;
            
             for(j = 1; j < no_of_frames; ++j){
             if(temp[j] > max){
             max = temp[j];
             pos = j;
             }
             }            
            }
frames[pos] = pages[i];
faults++;
        }
        
        printf("\n");
        
        for(j = 0; j < no_of_frames; ++j){
            printf("%d\t", frames[j]);
        }
    }
    
    printf("\n\nTotal Page Faults = %d", faults);
    
    return 0;
}
/*
Output
Enter number of frames: 4
Enter number of pages: 12 15 12 18 6 8 11 12 19 12 6 8 12 15 19 8
Enter page reference string: 
15	-1	-1	-1	
15	12	-1	-1	
15	12	18	-1	
15	12	18	6	
8	12	18	6	
8	12	11	6	
8	12	11	6	
8	12	19	6	
8	12	19	6	
8	12	19	6	
8	12	19	6	
8	12	19	6	

Total Page Faults = 7

*/

//MFU :

#include<stdio.h>
#define MAX 20

int frames[MAX],ref[MAX],mem[MAX][MAX],faults,
 sp,m,n,count[MAX];

void accept()
{
 int i;

 printf("Enter no.of frames:");
 scanf("%d", &n);

 printf("Enter no.of references:");
 scanf("%d", &m);

 printf("Enter reference string:\n");
 for(i=0;i<m;i++)
 {
  printf("[%d]=",i);
  scanf("%d",&ref[i]);
 }
}

void disp()
{
 int i,j;

 for(i=0;i<m;i++)
  printf("%3d",ref[i]);

 printf("\n\n");

 for(i=0;i<n;i++)
 {
  for(j=0;j<m;j++)
  {
   if(mem[i][j])
    printf("%3d",mem[i][j]);
   else
    printf("   ");
  }
  printf("\n");
 }

 printf("Total Page Faults: %d\n",faults);
}

int search(int pno)
{
 int i;

 for(i=0;i<n;i++)
 {
  if(frames[i]==pno)
   return i;
 }

 return -1;
}

int get_mfu(int sp)
{
 int i,max_i,max=-9999;

 i=sp;
 do
 {
  if(count[i]>max)
  {
   max = count[i];
   max_i = i;
  }
  i=(i+1)%n;
 }while(i!=sp);

 return max_i;
}

void mfu()
{
 int i,j,k;

 for(i=0;i<m && sp<n;i++)
 {
  k=search(ref[i]);
  if(k==-1)
  {
   frames[sp]=ref[i];
   count[sp]++;
   faults++;
   sp++;

   for(j=0;j<n;j++)
    mem[j][i]=frames[j];
  }
  else
   count[k]++;
  
 }

 sp=0;
 for(;i<m;i++)
 {
  k = search(ref[i]);
  if(k==-1)
  {
   sp = get_mfu(sp);
   frames[sp] = ref[i];
   count[sp]=1;
   faults++;
   sp = (sp+1)%n;

   for(j=0;j<n;j++)
    mem[j][i] = frames[j];
  }
  else
   count[k]++;
 }
}
      

int main()
{
 accept();
 mfu();
 disp();

 return 0;
}
/*
Output :
Enter no.of frames:4
Enter no.of references:12 15 12 18 6 8 11 12 19 12 6 8 12 15 19 8
Enter reference string:
[0]=[1]=[2]=[3]=[4]=[5]=[6]=[7]=[8]=[9]=[10]=[11]= 15 12 18  6  8 11 12 19 12  6  8 12

 15 15 15 15  8  8  8  8     8    12
    12 12 12 12 11 11 11    11    11
       18 18 18 18 12 12     6     6
           6  6  6  6 19    19    19
Total Page Faults: 10
*/
##################################################################################
##################################################################################
Set C:  I. Write  the  simulation  program  to  implement  demand  paging  
and  show  the  page scheduling and total number of page faults for the 
following given page reference string. Give input n as the number of memory
frames.  
Reference String: 2,5,2,8,5,4,1,2,3,2,6,1,2,5,9,8  
1) Implement MRU 2) Implement Second Chance Page Replacement. 
3) Least Frequently Used (LFU)
//MRU

#include<stdio.h>
#define MAX 20

int frames[MAX],ref[MAX],mem[MAX][MAX],faults,
 sp,m,n,count[MAX];

void accept()
{
 int i;

 printf("Enter no.of frames:");
 scanf("%d", &n);

 printf("Enter no.of references:");
 scanf("%d", &m);

 printf("Enter reference string:\n");
 for(i=0;i<m;i++)
 {
  printf("[%d]=",i);
  scanf("%d",&ref[i]);
 }
}

void disp()
{
 int i,j;

 for(i=0;i<m;i++)
  printf("%3d",ref[i]);

 printf("\n\n");

 for(i=0;i<n;i++)
 {
  for(j=0;j<m;j++)
  {
   if(mem[i][j])
    printf("%3d",mem[i][j]);
   else
    printf("   ");
  }
  printf("\n");
 }

 printf("Total Page Faults: %d\n",faults);
}

int search(int pno)
{
 int i;

 for(i=0;i<n;i++)
 {
  if(frames[i]==pno)
   return i;
 }

 return -1;
}

int get_mfu(int sp)
{
 int i,max_i,max=-9999;

 i=sp;
 do
 {
  if(count[i]>max)
  {
   max = count[i];
   max_i = i;
  }
  i=(i+1)%n;
 }while(i!=sp);

 return max_i;
}

void mfu()
{
 int i,j,k;

 for(i=0;i<m && sp<n;i++)
 {
  k=search(ref[i]);
  if(k==-1)
  {
   frames[sp]=ref[i];
   count[sp]++;
   faults++;
   sp++;

   for(j=0;j<n;j++)
    mem[j][i]=frames[j];
  }
  else
   count[k]++;
  
 }

 sp=0;
 for(;i<m;i++)
 {
  k = search(ref[i]);
  if(k==-1)
  {
   sp = get_mfu(sp);
   frames[sp] = ref[i];
   count[sp]=1;
   faults++;
   sp = (sp+1)%n;

   for(j=0;j<n;j++)
    mem[j][i] = frames[j];
  }
  else
   count[k]++;
 }
}
      

int main()
{
 accept();
 mfu();
 disp();

 return 0;
}

//LFU 
#include<stdio.h>
#define MAX 20

int frames[MAX],ref[MAX],mem[MAX][MAX],faults,
 sp,m,n,count[MAX];

void accept()
{
 int i;

 printf("Enter no.of frames:");
 scanf("%d", &n);

 printf("Enter no.of references:");
 scanf("%d", &m);

 printf("Enter reference string:\n");
 for(i=0;i<m;i++)
 {
  printf("[%d]=",i);
  scanf("%d",&ref[i]);
 }
}

void disp()
{
 int i,j;

 for(i=0;i<m;i++)
  printf("%3d",ref[i]);

 printf("\n\n");

 for(i=0;i<n;i++)
 {
  for(j=0;j<m;j++)
  {
   if(mem[i][j])
    printf("%3d",mem[i][j]);
   else
    printf("   ");
  }
  printf("\n");
 }

 printf("Total Page Faults: %d\n",faults);
}

int search(int pno)
{
 int i;

 for(i=0;i<n;i++)
 {
  if(frames[i]==pno)
   return i;
 }

 return -1;
}

int get_lfu(int sp)
{
 int i,min_i,min=9999;

 i=sp;
 do
 {
  if(count[i]<min)
  {
   min = count[i];
   min_i = i;
  }
  i=(i+1)%n;
 }while(i!=sp);

 return min_i;
}


void lfu()
{
 int i,j,k;

 for(i=0;i<m && sp<n;i++)
 {
  k=search(ref[i]);
  if(k==-1)
  {
   frames[sp]=ref[i];
   count[sp]++;
   faults++;
   sp++;

   for(j=0;j<n;j++)
    mem[j][i]=frames[j];
  }
  else
   count[k]++;
  
 }

 sp=0;
 for(;i<m;i++)
 {
  k = search(ref[i]);
  if(k==-1)
  {
   sp = get_lfu(sp);
   frames[sp] = ref[i];
   count[sp]=1;
   faults++;
   sp = (sp+1)%n;

   for(j=0;j<n;j++)
    mem[j][i] = frames[j];
  }
  else
   count[k]++;
 }
}
      

int main()
{
 accept();
 lfu();
 disp();

 return 0;
}

##################################################################################